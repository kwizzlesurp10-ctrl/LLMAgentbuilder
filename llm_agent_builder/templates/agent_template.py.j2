import os
from typing import Optional, List, Dict, Any
try:
    from llm_agent_builder.copilot_client import CopilotClient
    COPILOT_AVAILABLE = True
except ImportError:
    COPILOT_AVAILABLE = False
{% if enable_multi_step or tools %}
import json
{% endif %}

class {% if agent_name %}{{ agent_name }}{% else %}Agent{% endif %}:
    def __init__(self, api_key):
        if not COPILOT_AVAILABLE:
            raise ImportError("CopilotClient not available. Please ensure llm_agent_builder.copilot_client is installed.")
        self.client = CopilotClient(bearer_token=api_key)
        self.prompt = "{{- prompt -}}"
        {% if tools %}
        self.tools = {{ tools | tojson }}
        {% endif %}

    {% if tools %}
    def _execute_tool(self, tool_name: str, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a tool call. Override this method to implement custom tool logic."""
        # Default implementation - override in subclass for custom tools
        return {"result": f"Tool {tool_name} executed with input: {tool_input}"}
    {% endif %}

    {% if enable_multi_step %}
    def run_multi_step(self, task: str, max_steps: int = 5) -> str:
        """Run a multi-step workflow where the agent can iterate on the task."""
        messages = [{"role": "user", "content": f"{self.prompt}\n\nTask: {task}"}]
        final_result = None
        
        for step in range(max_steps):
            response = self.client.get_chat_completion(messages=messages)
            
            # Extract response content
            final_result = response.content
            messages.append({
                "role": "assistant",
                "content": response.content
            })
            
            # Check if task is complete (simple heuristic - can be enhanced)
            if "complete" in final_result.lower() or "finished" in final_result.lower():
                break
            
            # Add continuation prompt for next step
            if step < max_steps - 1:
                messages.append({
                    "role": "user",
                    "content": "Continue or refine your response if needed."
                })
        
        return final_result or "Multi-step workflow completed."
    {% endif %}

    def run(self, task: str{% if enable_multi_step %}, use_multi_step: bool = False{% endif %}):
        {% if enable_multi_step %}
        if use_multi_step:
            return self.run_multi_step(task)
        {% endif %}
        
        # Use GitHub Copilot chat completion API
        messages = [
            {"role": "user", "content": f"{self.prompt}\n\nTask: {task}"}
        ]
        
        response = self.client.get_chat_completion(messages=messages)
        return response.content

if __name__ == '__main__':
    import os
    import argparse
    from dotenv import load_dotenv

    load_dotenv()

    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Run the {% if agent_name %}{{ agent_name }}{% else %}Agent{% endif %} agent.")
    parser.add_argument("--task", default="{{- example_task -}}", help="The task to be performed by the agent")
    args = parser.parse_args()

    # Ensure API key is set (GitHub Copilot token)
    api_key = os.environ.get("GITHUB_COPILOT_TOKEN") or os.environ.get("GITHUB_PAT")
    if not api_key:
        raise ValueError("GITHUB_COPILOT_TOKEN or GITHUB_PAT environment variable not set. Please set it in your .env file or environment.")

    try:
        agent = {% if agent_name %}{{ agent_name }}{% else %}Agent{% endif %}(api_key=api_key)
        print(f"Running {% if agent_name %}{{ agent_name }}{% else %}Agent{% endif %} with task: {args.task}\n")
        result = agent.run(args.task)
        print("Response:")
        print("-" * 50)
        print(result)
        print("-" * 50)
    except Exception as e:
        print(f"Error running agent: {e}")
