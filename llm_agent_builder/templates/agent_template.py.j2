import anthropic
import os
from typing import Optional, List, Dict, Any
{% if enable_multi_step or tools %}
import json
{% endif %}

class {{ agent_name }}:
    def __init__(self, api_key):
        self.client = anthropic.Anthropic(api_key=api_key)
        self.prompt = "{{- prompt -}}"
        {% if tools %}
        self.tools = {{ tools | tojson }}
        {% endif %}

    {% if tools %}
    def _execute_tool(self, tool_name: str, tool_input: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a tool call. Override this method to implement custom tool logic."""
        # Default implementation - override in subclass for custom tools
        return {"result": f"Tool {tool_name} executed with input: {tool_input}"}
    {% endif %}

    {% if enable_multi_step %}
    def run_multi_step(self, task: str, max_steps: int = 5) -> str:
        """Run a multi-step workflow where the agent can iterate on the task."""
        messages = [{"role": "user", "content": task}]
        final_result = None
        
        for step in range(max_steps):
            response = self.client.messages.create(
                model=os.environ.get("ANTHROPIC_MODEL", "{{ model }}"),
                max_tokens=2048,
                system=self.prompt,
                messages=messages{% if tools %},
                tools=self.tools{% endif %}
            )
            
            # Handle tool use if present
            {% if tools %}
            if response.stop_reason == "tool_use":
                tool_uses = [block for block in response.content if block.type == "tool_use"]
                for tool_use in tool_uses:
                    tool_result = self._execute_tool(tool_use.name, tool_use.input)
                    messages.append({
                        "role": "assistant",
                        "content": response.content
                    })
                    messages.append({
                        "role": "user",
                        "content": [{
                            "type": "tool_result",
                            "tool_use_id": tool_use.id,
                            "content": json.dumps(tool_result)
                        }]
                    })
                continue
            {% endif %}
            
            # Extract text response
            text_content = [block.text for block in response.content if block.type == "text"]
            if text_content:
                final_result = text_content[0]
                messages.append({
                    "role": "assistant",
                    "content": response.content
                })
                
                # Check if task is complete (simple heuristic - can be enhanced)
                if "complete" in final_result.lower() or "finished" in final_result.lower():
                    break
            
            # Add continuation prompt for next step
            if step < max_steps - 1:
                messages.append({
                    "role": "user",
                    "content": "Continue or refine your response if needed."
                })
        
        return final_result or "Multi-step workflow completed."
    {% endif %}

    def run(self, task: str{% if enable_multi_step %}, use_multi_step: bool = False{% endif %}):
        {% if enable_multi_step %}
        if use_multi_step:
            return self.run_multi_step(task)
        {% endif %}
        
        response = self.client.messages.create(
            model=os.environ.get("ANTHROPIC_MODEL", "{{ model }}"),
            max_tokens=2048,
            system=self.prompt,
            messages=[
                {"role": "user", "content": task}
            ]{% if tools %},
            tools=self.tools{% endif %}
        )
        
        {% if tools %}
        # Handle tool use in single-step mode
        if response.stop_reason == "tool_use":
            tool_uses = [block for block in response.content if block.type == "tool_use"]
            tool_results = []
            for tool_use in tool_uses:
                tool_result = self._execute_tool(tool_use.name, tool_use.input)
                tool_results.append({
                    "type": "tool_result",
                    "tool_use_id": tool_use.id,
                    "content": json.dumps(tool_result)
                })
            
            # Get final response after tool execution
            follow_up = self.client.messages.create(
                model=os.environ.get("ANTHROPIC_MODEL", "{{ model }}"),
                max_tokens=2048,
                system=self.prompt,
                messages=[
                    {"role": "user", "content": task},
                    {"role": "assistant", "content": response.content},
                    {"role": "user", "content": tool_results}
                ]
            )
            return follow_up.content[0].text
        {% endif %}
        
        return response.content[0].text

if __name__ == '__main__':
    import os
    import argparse
    from dotenv import load_dotenv

    load_dotenv()

    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Run the {{ agent_name }} agent.")
    parser.add_argument("--task", default="{{- example_task -}}", help="The task to be performed by the agent")
    args = parser.parse_args()

    # Ensure API key is set
    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if not api_key:
        raise ValueError("ANTHROPIC_API_KEY environment variable not set. Please set it in your .env file or environment.")

    try:
        agent = {{ agent_name }}(api_key=api_key)
        print(f"Running {{ agent_name }} with task: {args.task}\n")
        result = agent.run(args.task)
        print("Response:")
        print("-" * 50)
        print(result)
        print("-" * 50)
    except Exception as e:
        print(f"Error running agent: {e}")
